(defun (htsize n)
  (cond ((<= n 101)    101)
        ((<= n 199)    199)
        ((<= n 499)    499)
        ((<= n 997)    997)
        ((<= n 1997)  1997)
        ((<= n 4999)  4999)
        ((<= n 9973)  9973)
        (else        19997)))

(defun (mkht z)
  (cons 0 (mkvec (htsize z) nil)))

(defun (hash x k)
  (let* ((s  (symname x))
         (ks (ssize s)))
    (let loop ((h 0)
               (i 0))
      (if (>= i ks)
          h
          (loop (rem (+ (* 31 h) (charval (sref s i)))
                     k)
                (+ 1 i))))))

(defun (htref h k)
  (let ((i (hash k (vsize (cdr h)))))
    (cond ((assq k (vref (cdr h) i))
            => cdr)
          (else
            nil))))

(defun (htgrow h)
  (let* ((k  (htsize (+ 1 (vsize (cdr h)))))
         (h* (mkht k)))
    (let loop ((i 0)
               (k (vsize (cdr h))))
      (cond ((>= i k)
              (setcar h (car h*))
              (setcdr h (cdr h*)))
            (else
              (foreach (lambda (x)
                         (htset h* (car x) (cdr x)))
                       (vref (cdr h) i))
              (loop (+ 1 i) k))))))

(defun (htset h k v)
  (if (> (car h) (vsize (cdr h)))
      (htgrow h))
  (let ((i (hash k (vsize (cdr h)))))
    (cond ((assq k (vref (cdr h) i))
            => (lambda (x)
                 (setcdr x v)))
          (else
            (setcar h (+ 1 (car h)))
            (vset (cdr h)
                  i
                  (cons (cons k v)
                        (vref (cdr h) i)))))))

(defun (htdel h k)
  (let ((i (hash k (vsize (cdr h)))))
    (cond ((null (vref (cdr h) i))
            nil)
          ((eq k (caar (vref (cdr h) i)))
            (vset (cdr h) i (cdr (vref (cdr h) i)))
            t)
          (else
            (let loop ((as (vref (cdr h) i)))
              (cond ((null as) nil)
                    ((eq k (caadr as))
                      (setcdr as (cddr as))
                      t)
                    ((null (cdr as)) nil)
                    (else (loop (cdr as)))))))))
